# 2020_11_10



信安管理考试复习



## Leetcode 每日一题：

题目描述：

```
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

题目链接：

```
https://leetcode-cn.com/problems/next-permutation/
```

题目难点在于，需要使用常数的空间。所以暴力跑全排列什么的应该用不上了。所以我的想法是找规律，进行特判。



总体的思路是这样的，从后往前看，如果已经是升序(倒着升序，正着降序)，表示他在这个范围内操作，已经不能再变大了，如

```c
{1,2,3,6,5,4} 
```

的后三个数。

那么就要在加上一个数，看看能不能更大，即加上这个数，就不是降序排列了。

所以我们需要处理的数据，实际上是这个样子的：

```
{1, 2, 3, 6, 5 ,4}
不用管 | * | 降序排好了
```

一个朴素的想法就是，在降序排好的里面，找一个比`*`大的最小的数，和`*`处交换，交换之后，是这个样子

```
{1, 2， 4， 6，5，3}
```

之后，只需要对后三位排序即可.

